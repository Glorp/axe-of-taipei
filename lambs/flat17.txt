Emacs Lisp-evaluating (start-lamb <x>) should start the thing:
(Pictures generated by the Racket-thing will go in a dir called <x>.)

Put cursor on the end of next line and do C-x C-e:
(start-lamb "flat17")

#:scale 3/2

(insert-pic "flat17/img0.png")

 

#:drawings typey


C-e with cursor on the #:slide help-line below for more instructions.

#:slide help




----

#:slide test



#:slide a-proof

(insert-pic "flat17/img2.png")

 



#:slide symbols

∧ is for conjunction, "and"
∨ is for disjunction, "or"
⊃ is for implication



#:slide sequents

P ⊢ Q
"from P I know Q"

can be multiple things before the turnstile (⊢)
O, P ⊢ Q
"from O *and* P I know Q"

can't be multuple things after the turnstile
(but if there could be, it'd be like
O, P ⊢ Q, R
"from O *and* P I know Q *or* R")



#:slide rules

(insert-pic "flat17/img3.png")

 



#:slide proptypes

Propositions as Types
Philip Wadler
http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf

We can describe Howard’s observation as follows:

• Conjunction A & B corresponds to Cartesian product A × B,
  that is, a record with two fields, also known as a pair. A proof
  of the proposition A & B consists of a proof of A and a proof of
  B. Similarly, a value of type A × B consists of a value of type
  A and a value of type B.

• Disjunction A ∨ B corresponds to a disjoint sum A + B, that
  is, a variant with two alternatives. A proof of the proposition
  A ∨ B consists of either a proof of A or a proof of B, including
  an indication of which of the two has been proved. Similarly, a
  value of type A + B consists of either a value of type A or a
  value of type B, including an indication of whether this is a left
  or right summand.

• Implication A ⊃ B corresponds to function space A → B. A
  proof of the proposition A ⊃ B consists of a procedure that
  given a proof of A yields a proof of B. Similarly, a value of
  type A → B consists of a function that when applied to a value
  of type A returns a value of type B.



#:slide translation

so,
instead of ⊃ we will write →
instead of ∧ (or &) we will write ×
instead of ∨ we will write +



#:slide a-proof-typey

(insert-pic "flat17/img4.png")

 



#:slide lang

and we will program in a language that works something like,
Exp u :=
  x                     variable

  λx.u                  abstraction, : A → B
  u1 u2                 application

  (u1, u2)              pair/tuple, : A × B
  fst u                 first projection
  snd u                 second projection

  left u                left injection, : A + B
  right u               right injection, : A + B
  case u1 of            case analysis
      left x1 => u2
    | right x2 => u3



#:slide axioms

(insert-pic "flat17/img5.png")

 



#:slide hypo-examples

(insert-pic "flat17/img6.png")

 

(insert-pic "flat17/img7.png")

 

(insert-pic "flat17/img8.png")

 



#:slide structural-rules

(insert-pic "flat17/img9.png")

 



#:slide weakening-examples

(insert-pic "flat17/img10.png")

 

(insert-pic "flat17/img11.png")

 

(insert-pic "flat17/img12.png")

 



#:slide function-rules

(insert-pic "flat17/img13.png")

 



#:slide function-example

(insert-pic "flat17/img14.png")

 



A -> A
λx.x

(insert-pic "flat17/img14.png")

 


A -> B -> A
λx.λy.x

(insert-pic "flat17/img15.png")

 



A -> B -> A
λx.λy.y

(insert-pic "flat17/img16.png")

 


(A -> B) -> A -> B
λf.λx.f x

(insert-pic "flat17/img17.png")

 

A -> A -> A
λx.λy.x

(insert-pic "flat17/img18.png")

 


A -> A -> A
λx.λy.y

(insert-pic "flat17/img19.png")

 


#:slide product-rules

(insert-pic "flat17/img20.png")

 

A * B -> B
λp.snd p

(insert-pic "flat17/img21.png")

 


A -> B -> A * B
λx.λy.(x, y)

(insert-pic "flat17/img22.png")

 


A -> B -> A * B
λx.λy.(y, y)

(insert-pic "flat17/img23.png")

 



A -> B -> A * B
λx.λy.(y, x)

(insert-pic "flat17/img24.png")

 


A -> B -> A * B
λx.λy.((y, x)

A * B -> B
λp.fst p

(insert-pic "flat17/img25.png")

 



A * B -> B
λp.fst (snd p, fst p)

(insert-pic "flat17/img26.png")

 


#:slide sum-rules

(insert-pic "flat17/img27.png")

 


A -> A + B
λx.left x

(insert-pic "flat17/img28.png")

 

B -> A + B
λx.right x

(insert-pic "flat17/img29.png")

 


A + A -> (A -> B) -> B
λs.λf.case s of
          left x => f x
        | right y => f y

(insert-pic "flat17/img30.png")

 


((A -> C) * (B -> C)) -> A + B -> C
λp.λs.case s of
          left x => (fst p) x
        | right x => (snd p) x

(insert-pic "flat17/img31.png")

 

#:slide a-proof-typey

(insert-pic "flat17/img4.png")

 


#:drawings logicy

okay :)

(A * B -> C) -> A -> B -> C
λf.λx.λy.f (x, y)

(insert-pic "flat17/img2.png")

 

(insert-pic "flat17/img4.png")

 


(A -> A) -> A -> A
λf.λx.x

(insert-pic "flat17/img32.png")

 


(A -> A) -> A -> A
λf.λx.f (f (f x))

(insert-pic "flat17/img33.png")

 














#:slide belt-and-suspenders

A Theory of Type Polymorphism in Programming
Robin Milner
http://tfeng.me/papers/milner78theory.pdf

Well-typed programs cannot go wrong.
They also cannot go wrong if they cannot go at all.


github
Glorp

axe-of-taipei























